<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Yuanyuan Yan" />

<meta name="date" content="2022-12-09" />

<title>Introduction to StatComp22011</title>

<script>// Hide empty <a> tag within highlighted CodeBlock for screen reader accessibility (see https://github.com/jgm/pandoc/issues/6352#issuecomment-626106786) -->
// v0.0.1
// Written by JooYoung Seo (jooyoung@psu.edu) and Atsushi Yasumoto on June 1st, 2020.

document.addEventListener('DOMContentLoaded', function() {
  const codeList = document.getElementsByClassName("sourceCode");
  for (var i = 0; i < codeList.length; i++) {
    var linkList = codeList[i].getElementsByTagName('a');
    for (var j = 0; j < linkList.length; j++) {
      if (linkList[j].innerHTML === "") {
        linkList[j].setAttribute('aria-hidden', 'true');
      }
    }
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>


<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Introduction to StatComp22011</h1>
<h4 class="author">Yuanyuan Yan</h4>
<h4 class="date">2022-12-09</h4>



<div id="overview" class="section level2">
<h2>Overview</h2>
<p><strong>StatComp22011</strong> is a R package developed to solve the two categories classification problem in medical field. Two functions are considered, namely, <em>SMAP_weights</em>() and traditional method <em>logistic_regression</em>() (predicting the response using eighteen variables). The former is written in R version and the latter is written in Rcpp. Namely <em>SMAP_weights</em> for R and <em>logistic_regression</em> for C++.</p>
<p>##Function Compared with logistics regression, SMAP(semi-parameter moving average method) avoid the process of model selection and the results are more robust when the model form is misspecified. Though many scholars have used this method to classification problems, they use the training set to estimate the model weights, which deviates from their aim of predicting the optimal outcome. Thus, I improved this method by inserting a validation set to estimate the model weights and allowing discrete variables in the explanatory variables.</p>
<p>The <em>SMAP_weights</em> function can give the estimated model weights and the hitrate of both the original SMAP methods and improved SMAP methods to make comparison. And the Rcpp function <em>logistic_regression</em> can return the results of traditional logistic regression method to compare with those of the semi-parameter models.</p>
<p>##Data The dataset twotypeVehicle contains 430 samples. Each sample has 18 attributes and a vehicle type either “bus” or “opel”. This dataset can be used to build a two catergories classification model.</p>
<p>The source R code for <em>SMAP_weights</em> is as follows:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a>SMAP_weights&lt;-<span class="cf">function</span>(data,p,p_dis,n_D){</span>
<span id="cb1-2"><a href="#cb1-2"></a>  <span class="co">#编写函数Design.matrix</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>  Design.matrix &lt;-<span class="st"> </span><span class="cf">function</span>(U, x, kn, degree,p,n)</span>
<span id="cb1-4"><a href="#cb1-4"></a>  {</span>
<span id="cb1-5"><a href="#cb1-5"></a>    q=kn<span class="op">+</span>degree<span class="op">+</span><span class="dv">1</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>    B=<span class="kw">bSpline</span>(U,<span class="dt">df=</span>q,<span class="dt">intercept=</span><span class="ot">TRUE</span>,<span class="dt">degree=</span>degree)          </span>
<span id="cb1-7"><a href="#cb1-7"></a>    Num&lt;-p<span class="op">*</span>(q)</span>
<span id="cb1-8"><a href="#cb1-8"></a>    xx&lt;-<span class="kw">matrix</span>(<span class="dv">0</span>,n,Num)</span>
<span id="cb1-9"><a href="#cb1-9"></a>    Bb&lt;-<span class="kw">array</span>(<span class="dv">0</span>,<span class="dt">dim=</span><span class="kw">c</span>(p,Num,n)) </span>
<span id="cb1-10"><a href="#cb1-10"></a>    <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n)  </span>
<span id="cb1-11"><a href="#cb1-11"></a>    {</span>
<span id="cb1-12"><a href="#cb1-12"></a>      <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>p)</span>
<span id="cb1-13"><a href="#cb1-13"></a>      {Bb[i,((i<span class="dv">-1</span>)<span class="op">*</span>(q)<span class="op">+</span><span class="dv">1</span>)<span class="op">:</span>(i<span class="op">*</span>(q)),j]&lt;-B[j,] }</span>
<span id="cb1-14"><a href="#cb1-14"></a>      xx[j,]&lt;-x[j,]<span class="op">%*%</span>Bb[,,j]</span>
<span id="cb1-15"><a href="#cb1-15"></a>    }</span>
<span id="cb1-16"><a href="#cb1-16"></a>    design =<span class="st"> </span><span class="kw">list</span>(<span class="dt">Bb =</span> Bb, <span class="dt">xx =</span> xx,<span class="dt">B=</span>B)</span>
<span id="cb1-17"><a href="#cb1-17"></a>    <span class="kw">return</span>(design)</span>
<span id="cb1-18"><a href="#cb1-18"></a>  } </span>
<span id="cb1-19"><a href="#cb1-19"></a>  </span>
<span id="cb1-20"><a href="#cb1-20"></a>  <span class="co">###数据输入</span></span>
<span id="cb1-21"><a href="#cb1-21"></a>  realdata&lt;-data</span>
<span id="cb1-22"><a href="#cb1-22"></a>  J=<span class="dv">2</span><span class="co">#二分类预测问题</span></span>
<span id="cb1-23"><a href="#cb1-23"></a>  HitRite&lt;-<span class="dv">0</span></span>
<span id="cb1-24"><a href="#cb1-24"></a>  HitRite1&lt;-<span class="dv">0</span></span>
<span id="cb1-25"><a href="#cb1-25"></a>  HAT.W.VEC_B=<span class="kw">matrix</span>(<span class="dv">0</span>,<span class="dv">1</span>,p<span class="op">-</span>p_dis)</span>
<span id="cb1-26"><a href="#cb1-26"></a>  HAT.W.VEC_B_new=<span class="kw">matrix</span>(<span class="dv">0</span>,<span class="dv">1</span>,p<span class="op">-</span>p_dis)</span>
<span id="cb1-27"><a href="#cb1-27"></a>  <span class="co">##############改进后的权重分析###############</span></span>
<span id="cb1-28"><a href="#cb1-28"></a>  <span class="co">############model averaging varying coefficient model#(SMAP)</span></span>
<span id="cb1-29"><a href="#cb1-29"></a>  <span class="co">####estimate model weights################</span></span>
<span id="cb1-30"><a href="#cb1-30"></a>  <span class="co">####B-spline################</span></span>
<span id="cb1-31"><a href="#cb1-31"></a>  <span class="co">#数据集划分(训练集：测试集：验证集=8:1:1)</span></span>
<span id="cb1-32"><a href="#cb1-32"></a>  train.rows&lt;-<span class="kw">sample</span>(n_D,n_D<span class="op">*</span><span class="fl">0.8</span>)</span>
<span id="cb1-33"><a href="#cb1-33"></a>  valid.rows&lt;-<span class="kw">sample</span>(<span class="kw">setdiff</span>(<span class="kw">seq</span>(<span class="dv">1</span><span class="op">:</span>n_D),train.rows),n_D<span class="op">*</span><span class="fl">0.1</span>)</span>
<span id="cb1-34"><a href="#cb1-34"></a>  test.rows&lt;-<span class="kw">setdiff</span>(<span class="kw">seq</span>(<span class="dv">1</span><span class="op">:</span>n_D),<span class="kw">union</span>(train.rows,valid.rows))</span>
<span id="cb1-35"><a href="#cb1-35"></a>  train&lt;-realdata[train.rows,]</span>
<span id="cb1-36"><a href="#cb1-36"></a>  valid&lt;-realdata[valid.rows,]</span>
<span id="cb1-37"><a href="#cb1-37"></a>  test&lt;-realdata[test.rows,]</span>
<span id="cb1-38"><a href="#cb1-38"></a>  </span>
<span id="cb1-39"><a href="#cb1-39"></a>  n_tr=<span class="kw">dim</span>(train)[<span class="dv">1</span>];n_val=<span class="kw">dim</span>(valid)[<span class="dv">1</span>];n_test=<span class="kw">dim</span>(test)[<span class="dv">1</span>]</span>
<span id="cb1-40"><a href="#cb1-40"></a>  x_tr=train[,<span class="dv">1</span><span class="op">:</span>p]</span>
<span id="cb1-41"><a href="#cb1-41"></a>  y_tr_sta=train[,(p<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb1-42"><a href="#cb1-42"></a>  y_tr_sta[<span class="kw">which</span>(y_tr_sta<span class="op">==</span><span class="dv">0</span>)]=<span class="dv">2</span></span>
<span id="cb1-43"><a href="#cb1-43"></a>  y_tr=<span class="kw">matrix</span>(<span class="dv">0</span>,n_tr,<span class="dv">2</span>)</span>
<span id="cb1-44"><a href="#cb1-44"></a>  y_tr[<span class="kw">which</span>(y_tr_sta<span class="op">==</span><span class="dv">1</span>),<span class="dv">1</span>]=<span class="dv">1</span></span>
<span id="cb1-45"><a href="#cb1-45"></a>  y_tr[<span class="kw">which</span>(y_tr_sta<span class="op">==</span><span class="dv">2</span>),<span class="dv">2</span>]=<span class="dv">1</span></span>
<span id="cb1-46"><a href="#cb1-46"></a>  <span class="co">#y_sta_tr=y_sta_D[out]</span></span>
<span id="cb1-47"><a href="#cb1-47"></a>  x_val=valid[,<span class="dv">1</span><span class="op">:</span>p]</span>
<span id="cb1-48"><a href="#cb1-48"></a>  y_val_sta=valid[,(p<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb1-49"><a href="#cb1-49"></a>  y_val_sta[<span class="kw">which</span>(y_val_sta<span class="op">==</span><span class="dv">0</span>)]=<span class="dv">2</span></span>
<span id="cb1-50"><a href="#cb1-50"></a>  y_val=<span class="kw">matrix</span>(<span class="dv">0</span>,n_val,<span class="dv">2</span>)</span>
<span id="cb1-51"><a href="#cb1-51"></a>  y_val[<span class="kw">which</span>(y_val_sta<span class="op">==</span><span class="dv">1</span>),<span class="dv">1</span>]=<span class="dv">1</span></span>
<span id="cb1-52"><a href="#cb1-52"></a>  y_val[<span class="kw">which</span>(y_val_sta<span class="op">==</span><span class="dv">2</span>),<span class="dv">2</span>]=<span class="dv">1</span></span>
<span id="cb1-53"><a href="#cb1-53"></a>  x_test=test[,<span class="dv">1</span><span class="op">:</span>p]</span>
<span id="cb1-54"><a href="#cb1-54"></a>  y_test_sta=test[,(p<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb1-55"><a href="#cb1-55"></a>  y_test_sta[<span class="kw">which</span>(y_test_sta<span class="op">==</span><span class="dv">0</span>)]=<span class="dv">2</span></span>
<span id="cb1-56"><a href="#cb1-56"></a>  y_test=<span class="kw">matrix</span>(<span class="dv">0</span>,n_test,<span class="dv">2</span>)</span>
<span id="cb1-57"><a href="#cb1-57"></a>  y_test[<span class="kw">which</span>(y_test_sta<span class="op">==</span><span class="dv">1</span>),<span class="dv">1</span>]=<span class="dv">1</span></span>
<span id="cb1-58"><a href="#cb1-58"></a>  y_test[<span class="kw">which</span>(y_test_sta<span class="op">==</span><span class="dv">2</span>),<span class="dv">2</span>]=<span class="dv">1</span></span>
<span id="cb1-59"><a href="#cb1-59"></a>  </span>
<span id="cb1-60"><a href="#cb1-60"></a>  n=n_D<span class="op">-</span>n_test<span class="op">-</span>n_val</span>
<span id="cb1-61"><a href="#cb1-61"></a>  kn=<span class="kw">floor</span>((n)<span class="op">^</span>(<span class="dv">1</span><span class="op">/</span><span class="dv">5</span>));degree=<span class="dv">1</span>;q=kn<span class="op">+</span>degree<span class="op">+</span><span class="dv">1</span></span>
<span id="cb1-62"><a href="#cb1-62"></a>  h=<span class="dv">1</span><span class="op">*</span>(((J<span class="dv">-1</span>)<span class="op">*</span>p)<span class="op">/</span>n)<span class="op">^</span>(<span class="fl">0.2</span>)</span>
<span id="cb1-63"><a href="#cb1-63"></a>  </span>
<span id="cb1-64"><a href="#cb1-64"></a>  </span>
<span id="cb1-65"><a href="#cb1-65"></a>  <span class="co">#############bspline改进前###########################</span></span>
<span id="cb1-66"><a href="#cb1-66"></a>  hat.P=<span class="kw">array</span>(<span class="dv">0</span>,<span class="dt">dim=</span><span class="kw">c</span>(n_tr,<span class="dv">2</span>,p<span class="op">-</span>p_dis))</span>
<span id="cb1-67"><a href="#cb1-67"></a>  hat.P.test=<span class="kw">array</span>(<span class="dv">0</span>,<span class="dt">dim=</span><span class="kw">c</span>(n_test,<span class="dv">2</span>,p<span class="op">-</span>p_dis))</span>
<span id="cb1-68"><a href="#cb1-68"></a>  <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>(p<span class="op">-</span>p_dis)){</span>
<span id="cb1-69"><a href="#cb1-69"></a>    x_sub=<span class="kw">Design.matrix</span>(x_tr[,j<span class="op">+</span>p_dis], <span class="kw">as.matrix</span>(<span class="kw">cbind</span>(<span class="dv">1</span>,x_tr[,<span class="op">-</span>(j<span class="op">+</span>p_dis)])),kn,degree,<span class="dt">p=</span>p,<span class="dt">n=</span>n_tr)<span class="op">$</span>xx</span>
<span id="cb1-70"><a href="#cb1-70"></a>    x_test_sub=<span class="kw">Design.matrix</span>(x_test[,j<span class="op">+</span>p_dis],<span class="kw">as.matrix</span>(<span class="kw">cbind</span>(<span class="dv">1</span>,x_test[,<span class="op">-</span>(j<span class="op">+</span>p_dis)])),kn, degree,<span class="dt">p=</span>p,<span class="dt">n=</span>n_test)<span class="op">$</span>xx</span>
<span id="cb1-71"><a href="#cb1-71"></a>    lm0=<span class="kw">multinom</span>(y_tr<span class="op">~</span>x_sub<span class="op">+</span><span class="dv">0</span>)</span>
<span id="cb1-72"><a href="#cb1-72"></a>    hat.P[,,j]=lm0<span class="op">$</span>fitted.values</span>
<span id="cb1-73"><a href="#cb1-73"></a>    </span>
<span id="cb1-74"><a href="#cb1-74"></a>    hat.mu1=x_test_sub<span class="op">%*%</span>(<span class="kw">coefficients</span>(lm0)[<span class="dv">1</span>,])</span>
<span id="cb1-75"><a href="#cb1-75"></a>    hat.p1=<span class="dv">1</span><span class="op">/</span>(<span class="dv">1</span><span class="op">+</span><span class="kw">exp</span>(hat.mu1))</span>
<span id="cb1-76"><a href="#cb1-76"></a>    hat.p2=<span class="kw">exp</span>(hat.mu1)<span class="op">/</span>(<span class="dv">1</span><span class="op">+</span><span class="kw">exp</span>(hat.mu1))</span>
<span id="cb1-77"><a href="#cb1-77"></a>    hat.P.test[,,j]=<span class="kw">cbind</span>(hat.p1,hat.p2)</span>
<span id="cb1-78"><a href="#cb1-78"></a>  }</span>
<span id="cb1-79"><a href="#cb1-79"></a>  </span>
<span id="cb1-80"><a href="#cb1-80"></a>  hat.P.A=y.vec=<span class="ot">NULL</span> </span>
<span id="cb1-81"><a href="#cb1-81"></a>  <span class="cf">for</span>(c0 <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n_tr) {</span>
<span id="cb1-82"><a href="#cb1-82"></a>    hat.P.A=<span class="kw">rbind</span>(hat.P.A,hat.P[c0,,])</span>
<span id="cb1-83"><a href="#cb1-83"></a>    y.vec=<span class="kw">c</span>(y.vec,y_tr[c0,])</span>
<span id="cb1-84"><a href="#cb1-84"></a>  }</span>
<span id="cb1-85"><a href="#cb1-85"></a>  lm.opt=<span class="kw">solve.QP</span>(<span class="dt">Dmat=</span><span class="kw">t</span>(hat.P.A)<span class="op">%*%</span>hat.P.A, </span>
<span id="cb1-86"><a href="#cb1-86"></a>                  <span class="dt">dvec=</span><span class="kw">t</span>(y.vec)<span class="op">%*%</span>hat.P.A, <span class="dt">Amat=</span><span class="kw">cbind</span>(<span class="kw">rep</span>(<span class="dv">1</span>,p<span class="op">-</span>p_dis),<span class="kw">diag</span>(p<span class="op">-</span>p_dis)),</span>
<span id="cb1-87"><a href="#cb1-87"></a>                  <span class="dt">bvec=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="kw">rep</span>(<span class="dv">0</span>,p<span class="op">-</span>p_dis)), <span class="dt">meq=</span><span class="dv">1</span>) </span>
<span id="cb1-88"><a href="#cb1-88"></a>  w.opt=lm.opt<span class="op">$</span>solution</span>
<span id="cb1-89"><a href="#cb1-89"></a>  HAT.W.VEC_B[<span class="dv">1</span>,]=w.opt</span>
<span id="cb1-90"><a href="#cb1-90"></a>  </span>
<span id="cb1-91"><a href="#cb1-91"></a>  Hat.w.P=<span class="kw">matrix</span>(<span class="dv">0</span>,n_test,<span class="dv">2</span>)</span>
<span id="cb1-92"><a href="#cb1-92"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n_test){</span>
<span id="cb1-93"><a href="#cb1-93"></a>    <span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>J){</span>
<span id="cb1-94"><a href="#cb1-94"></a>      Hat.w.P[i,j]=<span class="kw">sum</span>(hat.P.test[i,j,]<span class="op">*</span>w.opt) </span>
<span id="cb1-95"><a href="#cb1-95"></a>    }</span>
<span id="cb1-96"><a href="#cb1-96"></a>  }</span>
<span id="cb1-97"><a href="#cb1-97"></a>  Hat.y=<span class="kw">apply</span>(Hat.w.P,<span class="dv">1</span>,which.max)</span>
<span id="cb1-98"><a href="#cb1-98"></a>  HitRate=<span class="kw">mean</span>(Hat.y<span class="op">==</span>y_test_sta)</span>
<span id="cb1-99"><a href="#cb1-99"></a>  </span>
<span id="cb1-100"><a href="#cb1-100"></a>  </span>
<span id="cb1-101"><a href="#cb1-101"></a>  <span class="co">#############bspline改进后###########################</span></span>
<span id="cb1-102"><a href="#cb1-102"></a>  hat.P.val=<span class="kw">array</span>(<span class="dv">0</span>,<span class="dt">dim=</span><span class="kw">c</span>(n_val,<span class="dv">2</span>,p<span class="op">-</span>p_dis))</span>
<span id="cb1-103"><a href="#cb1-103"></a>  hat.P.test=<span class="kw">array</span>(<span class="dv">0</span>,<span class="dt">dim=</span><span class="kw">c</span>(n_test,<span class="dv">2</span>,p<span class="op">-</span>p_dis))</span>
<span id="cb1-104"><a href="#cb1-104"></a>  <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>(p<span class="op">-</span>p_dis)){</span>
<span id="cb1-105"><a href="#cb1-105"></a>    x_sub=<span class="kw">Design.matrix</span>(x_tr[,j<span class="op">+</span>p_dis], <span class="kw">as.matrix</span>(<span class="kw">cbind</span>(<span class="dv">1</span>,x_tr[,<span class="op">-</span>(j<span class="op">+</span>p_dis)])),kn,degree,<span class="dt">p=</span>p,<span class="dt">n=</span>n_tr)<span class="op">$</span>xx</span>
<span id="cb1-106"><a href="#cb1-106"></a>    x_val_sub=<span class="kw">Design.matrix</span>(x_val[,j<span class="op">+</span>p_dis],<span class="kw">as.matrix</span>(<span class="kw">cbind</span>(<span class="dv">1</span>,x_val[,<span class="op">-</span>(j<span class="op">+</span>p_dis)])),kn,degree,<span class="dt">p=</span>p,<span class="dt">n=</span>n_val)<span class="op">$</span>xx</span>
<span id="cb1-107"><a href="#cb1-107"></a>    x_test_sub=<span class="kw">Design.matrix</span>(x_test[,j<span class="op">+</span>p_dis],<span class="kw">as.matrix</span>(<span class="kw">cbind</span>(<span class="dv">1</span>,x_test[,<span class="op">-</span>(j<span class="op">+</span>p_dis)])),kn, degree,<span class="dt">p=</span>p,<span class="dt">n=</span>n_test)<span class="op">$</span>xx</span>
<span id="cb1-108"><a href="#cb1-108"></a>    lm0=<span class="kw">multinom</span>(y_tr<span class="op">~</span>x_sub<span class="op">+</span><span class="dv">0</span>)</span>
<span id="cb1-109"><a href="#cb1-109"></a>    <span class="co">#hat.P[,,j]=lm0$fitted.values</span></span>
<span id="cb1-110"><a href="#cb1-110"></a>    </span>
<span id="cb1-111"><a href="#cb1-111"></a>    hat.mu1_val=x_val_sub<span class="op">%*%</span>(<span class="kw">coefficients</span>(lm0)[<span class="dv">1</span>,])</span>
<span id="cb1-112"><a href="#cb1-112"></a>    hat.p1_val=<span class="dv">1</span><span class="op">/</span>(<span class="dv">1</span><span class="op">+</span><span class="kw">exp</span>(hat.mu1_val))</span>
<span id="cb1-113"><a href="#cb1-113"></a>    hat.p2_val=<span class="kw">exp</span>(hat.mu1_val)<span class="op">/</span>(<span class="dv">1</span><span class="op">+</span><span class="kw">exp</span>(hat.mu1_val))</span>
<span id="cb1-114"><a href="#cb1-114"></a>    hat.P.val[,,j]=<span class="kw">cbind</span>(hat.p1_val,hat.p2_val)</span>
<span id="cb1-115"><a href="#cb1-115"></a>    </span>
<span id="cb1-116"><a href="#cb1-116"></a>    hat.mu1=x_test_sub<span class="op">%*%</span>(<span class="kw">coefficients</span>(lm0)[<span class="dv">1</span>,])</span>
<span id="cb1-117"><a href="#cb1-117"></a>    hat.p1=<span class="dv">1</span><span class="op">/</span>(<span class="dv">1</span><span class="op">+</span><span class="kw">exp</span>(hat.mu1))</span>
<span id="cb1-118"><a href="#cb1-118"></a>    hat.p2=<span class="kw">exp</span>(hat.mu1)<span class="op">/</span>(<span class="dv">1</span><span class="op">+</span><span class="kw">exp</span>(hat.mu1))</span>
<span id="cb1-119"><a href="#cb1-119"></a>    hat.P.test[,,j]=<span class="kw">cbind</span>(hat.p1,hat.p2)</span>
<span id="cb1-120"><a href="#cb1-120"></a>  }</span>
<span id="cb1-121"><a href="#cb1-121"></a>  </span>
<span id="cb1-122"><a href="#cb1-122"></a>  hat.P.A=y.vec=<span class="ot">NULL</span> </span>
<span id="cb1-123"><a href="#cb1-123"></a>  <span class="cf">for</span>(c0 <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n_val) {</span>
<span id="cb1-124"><a href="#cb1-124"></a>    hat.P.A=<span class="kw">rbind</span>(hat.P.A,hat.P.val[c0,,])</span>
<span id="cb1-125"><a href="#cb1-125"></a>    y.vec=<span class="kw">c</span>(y.vec,y_val[c0,])</span>
<span id="cb1-126"><a href="#cb1-126"></a>  }</span>
<span id="cb1-127"><a href="#cb1-127"></a>  </span>
<span id="cb1-128"><a href="#cb1-128"></a>  lm.opt=<span class="kw">solve.QP</span>(<span class="dt">Dmat=</span><span class="kw">t</span>(hat.P.A)<span class="op">%*%</span>hat.P.A, </span>
<span id="cb1-129"><a href="#cb1-129"></a>                  <span class="dt">dvec=</span><span class="kw">t</span>(y.vec)<span class="op">%*%</span>hat.P.A, <span class="dt">Amat=</span><span class="kw">cbind</span>(<span class="kw">rep</span>(<span class="dv">1</span>,(p<span class="op">-</span>p_dis)),<span class="kw">diag</span>(p<span class="op">-</span>p_dis)),</span>
<span id="cb1-130"><a href="#cb1-130"></a>                  <span class="dt">bvec=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="kw">rep</span>(<span class="dv">0</span>,p<span class="op">-</span>p_dis)), <span class="dt">meq=</span><span class="dv">1</span>) </span>
<span id="cb1-131"><a href="#cb1-131"></a>  w.opt=lm.opt<span class="op">$</span>solution</span>
<span id="cb1-132"><a href="#cb1-132"></a>  HAT.W.VEC_B_new[<span class="dv">1</span>,]=w.opt</span>
<span id="cb1-133"><a href="#cb1-133"></a>  </span>
<span id="cb1-134"><a href="#cb1-134"></a>  Hat.w.P=<span class="kw">matrix</span>(<span class="dv">0</span>,n_test,<span class="dv">2</span>)</span>
<span id="cb1-135"><a href="#cb1-135"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n_test){</span>
<span id="cb1-136"><a href="#cb1-136"></a>    <span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>J){</span>
<span id="cb1-137"><a href="#cb1-137"></a>      Hat.w.P[i,j]=<span class="kw">sum</span>(hat.P.test[i,j,]<span class="op">*</span>w.opt) </span>
<span id="cb1-138"><a href="#cb1-138"></a>    }</span>
<span id="cb1-139"><a href="#cb1-139"></a>  }</span>
<span id="cb1-140"><a href="#cb1-140"></a>  Hat.y=<span class="kw">apply</span>(Hat.w.P,<span class="dv">1</span>,which.max)</span>
<span id="cb1-141"><a href="#cb1-141"></a>  HitRate1=<span class="kw">mean</span>(Hat.y<span class="op">==</span>y_test_sta)</span>
<span id="cb1-142"><a href="#cb1-142"></a>  </span>
<span id="cb1-143"><a href="#cb1-143"></a>  results&lt;-<span class="kw">list</span>(<span class="kw">rbind</span>(HAT.W.VEC_B,HAT.W.VEC_B_new),<span class="kw">rbind</span>(HitRate,HitRate1))</span>
<span id="cb1-144"><a href="#cb1-144"></a>  <span class="kw">names</span>(results)&lt;-<span class="kw">c</span>(<span class="st">&quot;Weights&quot;</span>,<span class="st">&quot;Accuracy&quot;</span>)</span>
<span id="cb1-145"><a href="#cb1-145"></a>  <span class="kw">return</span>(results)</span>
<span id="cb1-146"><a href="#cb1-146"></a>}</span></code></pre></div>
<p>Note that: the input dataset must be arrange in a form of:(x1,x2,..,xp,y)</p>
<p>Here belows is an example of using the R function <em>SMAP_weights</em> ()</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">library</span>(StatComp22011)</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="kw">load</span>(<span class="st">&quot;~/Desktop/StatComp22011/data/twotypeVehicle.rda&quot;</span>)</span>
<span id="cb2-3"><a href="#cb2-3"></a>mydata&lt;-twotypeVehicle</span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="kw">SMAP_weights</span>(mydata,<span class="dv">18</span>,<span class="dv">0</span>,<span class="dv">430</span>)</span></code></pre></div>
<pre><code>## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 88.733653
## iter  20 value 46.844141
## iter  30 value 29.554140
## iter  40 value 6.145808
## iter  50 value 0.098176
## iter  60 value 0.000366
## final  value 0.000039 
## converged
## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 86.154884
## iter  20 value 51.514944
## iter  30 value 32.631587
## iter  40 value 6.692071
## iter  50 value 0.115855
## iter  60 value 0.000272
## final  value 0.000067 
## converged
## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 68.967932
## iter  20 value 48.369985
## iter  30 value 34.631862
## iter  40 value 8.121495
## iter  50 value 0.094840
## iter  60 value 0.000266
## final  value 0.000053 
## converged
## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 86.917402
## iter  20 value 36.128477
## iter  30 value 16.050430
## iter  40 value 2.680270
## iter  50 value 0.010557
## final  value 0.000058 
## converged
## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 88.620393
## iter  20 value 60.191616
## iter  30 value 32.902215
## iter  40 value 11.334436
## iter  50 value 0.359463
## iter  60 value 0.003123
## final  value 0.000004 
## converged
## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 51.454652
## iter  20 value 28.165325
## iter  30 value 11.616151
## iter  40 value 1.844099
## iter  50 value 0.137932
## iter  60 value 0.036147
## iter  70 value 0.012060
## iter  80 value 0.005475
## iter  90 value 0.002108
## iter 100 value 0.001048
## final  value 0.001048 
## stopped after 100 iterations
## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 66.184364
## iter  20 value 47.569625
## iter  30 value 26.946147
## iter  40 value 4.518704
## iter  50 value 0.062629
## iter  60 value 0.000344
## final  value 0.000046 
## converged
## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 55.704256
## iter  20 value 41.389136
## iter  30 value 24.235497
## iter  40 value 5.409985
## iter  50 value 0.084647
## iter  60 value 0.000150
## iter  60 value 0.000079
## iter  60 value 0.000076
## final  value 0.000076 
## converged
## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 59.647292
## iter  20 value 37.591085
## iter  30 value 24.741493
## iter  40 value 5.265974
## iter  50 value 0.142287
## iter  60 value 0.000480
## final  value 0.000046 
## converged
## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 94.348368
## iter  20 value 61.079647
## iter  30 value 39.952527
## iter  40 value 10.343173
## iter  50 value 0.257589
## iter  60 value 0.000658
## final  value 0.000081 
## converged
## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 45.303563
## iter  20 value 29.144257
## iter  30 value 14.374879
## iter  40 value 2.331828
## iter  50 value 0.018853
## iter  60 value 0.001054
## iter  70 value 0.000199
## final  value 0.000003 
## converged
## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 39.466926
## iter  20 value 25.180025
## iter  30 value 11.712414
## iter  40 value 1.873287
## iter  50 value 0.010981
## final  value 0.000013 
## converged
## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 86.277466
## iter  20 value 47.796987
## iter  30 value 25.079106
## iter  40 value 3.886655
## iter  50 value 0.020971
## final  value 0.000042 
## converged
## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 82.119230
## iter  20 value 50.601237
## iter  30 value 32.337578
## iter  40 value 7.353037
## iter  50 value 0.062695
## iter  60 value 0.000139
## iter  60 value 0.000077
## iter  60 value 0.000055
## final  value 0.000055 
## converged
## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 129.584761
## iter  20 value 57.935150
## iter  30 value 39.184044
## iter  40 value 13.755853
## iter  50 value 1.673287
## iter  60 value 0.013205
## final  value 0.000034 
## converged
## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 133.926496
## iter  20 value 61.240509
## iter  30 value 40.895585
## iter  40 value 15.267285
## iter  50 value 1.692865
## iter  60 value 0.004340
## final  value 0.000046 
## converged
## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 107.857368
## iter  20 value 68.462837
## iter  30 value 48.197785
## iter  40 value 16.076573
## iter  50 value 0.823450
## iter  60 value 0.002786
## final  value 0.000055 
## converged
## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 91.504371
## iter  20 value 58.721898
## iter  30 value 37.483687
## iter  40 value 10.656185
## iter  50 value 0.217969
## iter  60 value 0.000596
## final  value 0.000028 
## converged
## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 88.733653
## iter  20 value 46.844141
## iter  30 value 29.554140
## iter  40 value 6.145808
## iter  50 value 0.098176
## iter  60 value 0.000366
## final  value 0.000039 
## converged
## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 86.154884
## iter  20 value 51.514944
## iter  30 value 32.631587
## iter  40 value 6.692071
## iter  50 value 0.115855
## iter  60 value 0.000272
## final  value 0.000067 
## converged
## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 68.967932
## iter  20 value 48.369985
## iter  30 value 34.631862
## iter  40 value 8.121495
## iter  50 value 0.094840
## iter  60 value 0.000266
## final  value 0.000053 
## converged
## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 86.917402
## iter  20 value 36.128477
## iter  30 value 16.050430
## iter  40 value 2.680270
## iter  50 value 0.010557
## final  value 0.000058 
## converged
## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 88.620393
## iter  20 value 60.191616
## iter  30 value 32.902215
## iter  40 value 11.334436
## iter  50 value 0.359463
## iter  60 value 0.003123
## final  value 0.000004 
## converged
## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 51.454652
## iter  20 value 28.165325
## iter  30 value 11.616151
## iter  40 value 1.844099
## iter  50 value 0.137932
## iter  60 value 0.036147
## iter  70 value 0.012060
## iter  80 value 0.005475
## iter  90 value 0.002108
## iter 100 value 0.001048
## final  value 0.001048 
## stopped after 100 iterations
## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 66.184364
## iter  20 value 47.569625
## iter  30 value 26.946147
## iter  40 value 4.518704
## iter  50 value 0.062629
## iter  60 value 0.000344
## final  value 0.000046 
## converged
## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 55.704256
## iter  20 value 41.389136
## iter  30 value 24.235497
## iter  40 value 5.409985
## iter  50 value 0.084647
## iter  60 value 0.000150
## iter  60 value 0.000079
## iter  60 value 0.000076
## final  value 0.000076 
## converged
## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 59.647292
## iter  20 value 37.591085
## iter  30 value 24.741493
## iter  40 value 5.265974
## iter  50 value 0.142287
## iter  60 value 0.000480
## final  value 0.000046 
## converged
## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 94.348368
## iter  20 value 61.079647
## iter  30 value 39.952527
## iter  40 value 10.343173
## iter  50 value 0.257589
## iter  60 value 0.000658
## final  value 0.000081 
## converged
## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 45.303563
## iter  20 value 29.144257
## iter  30 value 14.374879
## iter  40 value 2.331828
## iter  50 value 0.018853
## iter  60 value 0.001054
## iter  70 value 0.000199
## final  value 0.000003 
## converged
## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 39.466926
## iter  20 value 25.180025
## iter  30 value 11.712414
## iter  40 value 1.873287
## iter  50 value 0.010981
## final  value 0.000013 
## converged
## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 86.277466
## iter  20 value 47.796987
## iter  30 value 25.079106
## iter  40 value 3.886655
## iter  50 value 0.020971
## final  value 0.000042 
## converged
## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 82.119230
## iter  20 value 50.601237
## iter  30 value 32.337578
## iter  40 value 7.353037
## iter  50 value 0.062695
## iter  60 value 0.000139
## iter  60 value 0.000077
## iter  60 value 0.000055
## final  value 0.000055 
## converged
## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 129.584761
## iter  20 value 57.935150
## iter  30 value 39.184044
## iter  40 value 13.755853
## iter  50 value 1.673287
## iter  60 value 0.013205
## final  value 0.000034 
## converged
## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 133.926496
## iter  20 value 61.240509
## iter  30 value 40.895585
## iter  40 value 15.267285
## iter  50 value 1.692865
## iter  60 value 0.004340
## final  value 0.000046 
## converged
## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 107.857368
## iter  20 value 68.462837
## iter  30 value 48.197785
## iter  40 value 16.076573
## iter  50 value 0.823450
## iter  60 value 0.002786
## final  value 0.000055 
## converged
## # weights:  182 (90 variable)
## initial  value 178.831973 
## iter  10 value 91.504371
## iter  20 value 58.721898
## iter  30 value 37.483687
## iter  40 value 10.656185
## iter  50 value 0.217969
## iter  60 value 0.000596
## final  value 0.000028 
## converged</code></pre>
<pre><code>## $Weights
##             [,1]       [,2]        [,3]        [,4]        [,5]          [,6]
## [1,] 0.002526558 0.00000000 0.002772290 0.002808471 0.290971975 -4.555711e-21
## [2,] 0.029251838 0.01447434 0.002166398 0.003673744 0.002516652 -1.145502e-18
##               [,7]         [,8]          [,9]       [,10]      [,11]
## [1,]  1.755973e-03 1.044683e-03  1.244871e-03 0.000259038 0.66297917
## [2,] -1.004850e-18 5.940831e-19 -1.386887e-19 0.005414972 0.02198188
##              [,12]        [,13]         [,14]       [,15]        [,16]
## [1,]  2.057072e-02 1.126721e-21 -4.773213e-21 0.002701356 2.717143e-03
## [2,] -4.396377e-18 9.163857e-01  4.134472e-03 0.000000000 7.278966e-19
##              [,17]        [,18]
## [1,] -8.673617e-19 7.647752e-03
## [2,]  2.120284e-18 7.613091e-19
## 
## $Accuracy
##               [,1]
## HitRate  0.9651163
## HitRate1 0.8720930</code></pre>
<p>The source Rcpp code for <em>logistic regression</em> is as follows:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a><span class="pp">#include</span><span class="im">&lt;vector&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="pp">#include</span><span class="im">&lt;Rcpp.h&gt;</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="pp">#include</span><span class="im">&lt;math.h&gt;</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="pp">#include</span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb5-5"><a href="#cb5-5"></a></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="kw">using</span> <span class="kw">namespace</span> Rcpp;</span>
<span id="cb5-8"><a href="#cb5-8"></a></span>
<span id="cb5-9"><a href="#cb5-9"></a>vector&lt;<span class="dt">double</span>&gt; groundTruth;</span>
<span id="cb5-10"><a href="#cb5-10"></a>vector&lt;vector&lt;<span class="dt">double</span>&gt; &gt; inputValues;</span>
<span id="cb5-11"><a href="#cb5-11"></a>vector&lt;<span class="dt">double</span>&gt; weight;</span>
<span id="cb5-12"><a href="#cb5-12"></a></span>
<span id="cb5-13"><a href="#cb5-13"></a></span>
<span id="cb5-14"><a href="#cb5-14"></a><span class="dt">long</span> epochs = <span class="dv">10</span>;</span>
<span id="cb5-15"><a href="#cb5-15"></a><span class="dt">double</span> lr = <span class="fl">0.001</span>;</span>
<span id="cb5-16"><a href="#cb5-16"></a><span class="dt">double</span> e = <span class="fl">2.71828</span>;</span>
<span id="cb5-17"><a href="#cb5-17"></a></span>
<span id="cb5-18"><a href="#cb5-18"></a></span>
<span id="cb5-19"><a href="#cb5-19"></a><span class="dt">void</span> updateWeight(<span class="dt">double</span> predicted, <span class="dt">double</span> expected, vector&lt;<span class="dt">double</span>&gt; inputs);</span>
<span id="cb5-20"><a href="#cb5-20"></a><span class="dt">void</span> getAcc();</span>
<span id="cb5-21"><a href="#cb5-21"></a><span class="dt">double</span> sigmoid(<span class="dt">double</span> z);</span>
<span id="cb5-22"><a href="#cb5-22"></a></span>
<span id="cb5-23"><a href="#cb5-23"></a></span>
<span id="cb5-24"><a href="#cb5-24"></a>NumericVector logistic_regression(NumericMatrix explain, NumericVector response);</span>
<span id="cb5-25"><a href="#cb5-25"></a></span>
<span id="cb5-26"><a href="#cb5-26"></a><span class="co">//&#39; @title A logistic regression method using Rcpp</span></span>
<span id="cb5-27"><a href="#cb5-27"></a><span class="co">//&#39; @description A logistic regression method using Rcpp</span></span>
<span id="cb5-28"><a href="#cb5-28"></a><span class="co">//&#39; @param explain the design matrix </span></span>
<span id="cb5-29"><a href="#cb5-29"></a><span class="co">//&#39; @param response the response vector y</span></span>
<span id="cb5-30"><a href="#cb5-30"></a><span class="co">//&#39; @return the estimated coefficients of variables</span></span>
<span id="cb5-31"><a href="#cb5-31"></a><span class="co">//&#39; @export</span></span>
<span id="cb5-32"><a href="#cb5-32"></a><span class="co">// [[Rcpp::export]]</span></span>
<span id="cb5-33"><a href="#cb5-33"></a>NumericVector logistic_regression(NumericMatrix explain, NumericVector response) {</span>
<span id="cb5-34"><a href="#cb5-34"></a>  <span class="dt">int</span> nr = explain.nrow();</span>
<span id="cb5-35"><a href="#cb5-35"></a>  <span class="dt">int</span> nc = explain.ncol();</span>
<span id="cb5-36"><a href="#cb5-36"></a>  <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; nc; i++) {</span>
<span id="cb5-37"><a href="#cb5-37"></a>    weight.push_back(<span class="fl">0.2</span>);</span>
<span id="cb5-38"><a href="#cb5-38"></a>  }</span>
<span id="cb5-39"><a href="#cb5-39"></a>  <span class="dt">long</span> i, j;</span>
<span id="cb5-40"><a href="#cb5-40"></a>  </span>
<span id="cb5-41"><a href="#cb5-41"></a>  <span class="co">// fill every sample attribution of dataset</span></span>
<span id="cb5-42"><a href="#cb5-42"></a>  <span class="cf">for</span> (<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; nr; k++) {</span>
<span id="cb5-43"><a href="#cb5-43"></a>    vector&lt;<span class="dt">double</span>&gt; inputRow;</span>
<span id="cb5-44"><a href="#cb5-44"></a>    <span class="cf">for</span> (<span class="dt">int</span> kk = <span class="dv">0</span>; kk &lt; nc; kk++) {</span>
<span id="cb5-45"><a href="#cb5-45"></a>      inputRow.push_back(explain(k, kk));</span>
<span id="cb5-46"><a href="#cb5-46"></a>    }</span>
<span id="cb5-47"><a href="#cb5-47"></a>    inputValues.push_back(inputRow);</span>
<span id="cb5-48"><a href="#cb5-48"></a>  }</span>
<span id="cb5-49"><a href="#cb5-49"></a>  </span>
<span id="cb5-50"><a href="#cb5-50"></a>  <span class="co">// fill ground truth</span></span>
<span id="cb5-51"><a href="#cb5-51"></a>  <span class="dt">int</span> n_true = response.size();</span>
<span id="cb5-52"><a href="#cb5-52"></a>  <span class="cf">for</span> (<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; n_true; k++) {</span>
<span id="cb5-53"><a href="#cb5-53"></a>    groundTruth.push_back(response[k]);</span>
<span id="cb5-54"><a href="#cb5-54"></a>  }</span>
<span id="cb5-55"><a href="#cb5-55"></a>  </span>
<span id="cb5-56"><a href="#cb5-56"></a>  <span class="cf">while</span> (epochs--) {</span>
<span id="cb5-57"><a href="#cb5-57"></a>    <span class="co">// cout &lt;&lt; &quot;********************----&quot; &lt;&lt; epochs &lt;&lt; endl;</span></span>
<span id="cb5-58"><a href="#cb5-58"></a>    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; inputValues.size(); i++) {</span>
<span id="cb5-59"><a href="#cb5-59"></a>      <span class="dt">double</span> yhat, z = <span class="dv">0</span>;</span>
<span id="cb5-60"><a href="#cb5-60"></a>      <span class="cf">for</span> (j = <span class="dv">0</span>; j &lt; inputValues[<span class="dv">0</span>].size(); j++) {</span>
<span id="cb5-61"><a href="#cb5-61"></a>        z += weight[j] * inputValues[i][j];</span>
<span id="cb5-62"><a href="#cb5-62"></a>      }</span>
<span id="cb5-63"><a href="#cb5-63"></a>      yhat = sigmoid(z);</span>
<span id="cb5-64"><a href="#cb5-64"></a>      </span>
<span id="cb5-65"><a href="#cb5-65"></a>      updateWeight(yhat, groundTruth[i], inputValues[i]);</span>
<span id="cb5-66"><a href="#cb5-66"></a>    }</span>
<span id="cb5-67"><a href="#cb5-67"></a>  }</span>
<span id="cb5-68"><a href="#cb5-68"></a>  </span>
<span id="cb5-69"><a href="#cb5-69"></a>  </span>
<span id="cb5-70"><a href="#cb5-70"></a>  getAcc();</span>
<span id="cb5-71"><a href="#cb5-71"></a>  NumericVector out(nc);</span>
<span id="cb5-72"><a href="#cb5-72"></a>  <span class="cf">for</span> (<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; nc; ++k) {</span>
<span id="cb5-73"><a href="#cb5-73"></a>    out[k] = weight[k];</span>
<span id="cb5-74"><a href="#cb5-74"></a>  }</span>
<span id="cb5-75"><a href="#cb5-75"></a>  <span class="cf">return</span> out;</span>
<span id="cb5-76"><a href="#cb5-76"></a>}</span>
<span id="cb5-77"><a href="#cb5-77"></a></span>
<span id="cb5-78"><a href="#cb5-78"></a><span class="dt">void</span> updateWeight(<span class="dt">double</span> yhat, <span class="dt">double</span> groundTruth, vector&lt;<span class="dt">double</span>&gt; inputValue) {</span>
<span id="cb5-79"><a href="#cb5-79"></a>  <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; inputValue.size(); i++) {</span>
<span id="cb5-80"><a href="#cb5-80"></a>    <span class="dt">double</span> gradientDescent;</span>
<span id="cb5-81"><a href="#cb5-81"></a>    gradientDescent = (yhat - groundTruth) * inputValue[i];</span>
<span id="cb5-82"><a href="#cb5-82"></a>    weight[i] = weight[i] - (lr * gradientDescent);</span>
<span id="cb5-83"><a href="#cb5-83"></a>  }</span>
<span id="cb5-84"><a href="#cb5-84"></a>}</span>
<span id="cb5-85"><a href="#cb5-85"></a></span>
<span id="cb5-86"><a href="#cb5-86"></a><span class="dt">double</span> sigmoid(<span class="dt">double</span> z) {</span>
<span id="cb5-87"><a href="#cb5-87"></a>  <span class="cf">return</span> <span class="dv">1</span>/(<span class="dv">1</span> + pow(e, (-<span class="dv">1</span> * z)));</span>
<span id="cb5-88"><a href="#cb5-88"></a>}</span>
<span id="cb5-89"><a href="#cb5-89"></a></span>
<span id="cb5-90"><a href="#cb5-90"></a><span class="dt">void</span> getAcc() {</span>
<span id="cb5-91"><a href="#cb5-91"></a>  </span>
<span id="cb5-92"><a href="#cb5-92"></a>  <span class="dt">long</span> correct = <span class="dv">0</span>, totalCases = inputValues.size();</span>
<span id="cb5-93"><a href="#cb5-93"></a>  </span>
<span id="cb5-94"><a href="#cb5-94"></a>  <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; totalCases; i++) {</span>
<span id="cb5-95"><a href="#cb5-95"></a>    <span class="dt">double</span> yhat, z = <span class="dv">0</span>;</span>
<span id="cb5-96"><a href="#cb5-96"></a>    <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; inputValues[<span class="dv">0</span>].size(); j++) {</span>
<span id="cb5-97"><a href="#cb5-97"></a>      z += weight[j] * inputValues[i][j];</span>
<span id="cb5-98"><a href="#cb5-98"></a>    }</span>
<span id="cb5-99"><a href="#cb5-99"></a>    </span>
<span id="cb5-100"><a href="#cb5-100"></a>    </span>
<span id="cb5-101"><a href="#cb5-101"></a>    yhat = (sigmoid(z) &lt; <span class="fl">0.5</span>) ? <span class="dv">0</span> : <span class="dv">1</span>;</span>
<span id="cb5-102"><a href="#cb5-102"></a>    </span>
<span id="cb5-103"><a href="#cb5-103"></a>    correct += (yhat == groundTruth[i]);</span>
<span id="cb5-104"><a href="#cb5-104"></a>    </span>
<span id="cb5-105"><a href="#cb5-105"></a>  }</span>
<span id="cb5-106"><a href="#cb5-106"></a>  <span class="co">//cout &lt;&lt; &quot;Accuracy is: &quot; &lt;&lt; (correct * 100) / (totalCases) &lt;&lt; &quot;%&quot; &lt;&lt; endl;</span></span>
<span id="cb5-107"><a href="#cb5-107"></a>  </span>
<span id="cb5-108"><a href="#cb5-108"></a>}</span></code></pre></div>
<p>Here belows is an example of using the Rcpp function <em>logistic regression</em> ()</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a>mydata&lt;-twotypeVehicle</span>
<span id="cb6-2"><a href="#cb6-2"></a>matrixx&lt;-<span class="kw">as.matrix</span>(mydata[,<span class="dv">1</span><span class="op">:</span><span class="dv">18</span>])</span>
<span id="cb6-3"><a href="#cb6-3"></a>y&lt;-mydata[,<span class="dv">19</span>]</span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="kw">logistic_regression</span>(matrixx,y)</span></code></pre></div>
<pre><code>##  [1] -0.07644656 -0.23493007 -6.26353423 -0.66127697  3.26117630 -1.65337773
##  [7] -0.61176461 -0.16810302  0.05658069 -1.29570710  3.53587791 -0.55241509
## [13]  2.50393874  4.69493389 -1.92531170 -1.61604418  0.77720254 -2.79821577</code></pre>
<p>The Accuracy is about 78%~80%(calculated it but cannot use &quot;cout’ in Rcpp )</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
